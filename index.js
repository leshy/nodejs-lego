// Generated by CoffeeScript 1.9.3
(function() {
  var _, async, backbone, fs, h, helpers, lego, path;

  path = require('path');

  backbone = require('backbone4000');

  _ = require('underscore');

  helpers = h = require('helpers');

  fs = require('fs');

  async = require('async');

  lego = exports.lego = backbone.Model.extend4000({
    initialize: function(options) {
      this.env = options.env;
      return this.legos = options.legos;
    }
  });

  exports.loadLegos = function(options, callback) {
    var env;
    if (options == null) {
      options = {};
    }
    options = _.extend({
      dir: helpers.path(path.dirname(require.main.filename) + 'node_modules'),
      legoClass: backbone.Model,
      prefix: 'lego_',
      env: {}
    }, options);
    env = options.env;
    console.log('reading dir', options.dir);
    return fs.readdir(options.dir, function(err, files) {
      var autoInit, legos;
      if (err) {
        return helpers.cbc(callback, err);
      }
      legos = {};
      _.each(files, function(fileName) {
        var filePath, name, newLego, ref, ref1, stats;
        if (options.prefix && fileName.indexOf(options.prefix) !== 0) {
          return;
        }
        filePath = helpers.path(options.dir, fileName);
        stats = fs.lstatSync(filePath);
        if (stats.isDirectory() || stats.isSymbolicLink()) {
          name = fileName.substr(options.prefix.length);
          console.log('loading module', fileName);
          if (options.legoClass) {
            newLego = options.legoClass.extend4000({
              name: name,
              env: env,
              legos: legos
            }, require(filePath).lego);
            newLego.prototype.settings = _.extend({}, newLego.prototype.settings || {}, ((ref = env.settings.module) != null ? ref[name] : void 0) || {});
          } else {
            newLego = require(filePath);
            newLego.settings = _.extend({}, newLego.settings || {}, ((ref1 = env.settings.module) != null ? ref1[name] : void 0) || {});
          }
          return legos[name] = new newLego({
            env: env
          });
        }
      });
      h.dictMap(legos, function(lego, name) {
        h.map(h.array(lego.after), function(targetName) {
          if (legos[targetName]) {
            return lego.requires = h.push(h.array(lego.requires), targetName);
          }
        });
        return h.map(h.array(lego.before), function(targetName) {
          var targetLego;
          if (targetLego = legos[targetName]) {
            return targetLego.requires = h.push(h.array(targetLego.requires), name);
          }
        });
      });
      autoInit = h.dictMap(legos, function(lego, name) {
        return h.push(h.array(lego.requires), function(callback) {
          return lego.init(function(err, data) {
            return callback(err, data);
          });
        });
      });
      return async.auto(autoInit, function(err, data) {
        return callback(err, legos);
      });
    });
  };

}).call(this);
